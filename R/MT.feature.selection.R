#' Title Selecting the informative MT variants
#'
#' @param distance_list the distance list of all MT variants generated by MT.feature.distance
#' @param MT_variants_detected_matrix the VAF matrix of all detected MT variants generated by ErrorMutmatrix_detect
#' @param dis_cutoff the cutoff of distance between top two peaks, the default value of dis_cutoff=0.02
#' @param sample_type if your lineages come from distinct cell lines or patients samples, which don't have the same ancestor, please et sample_type = 1. if your lineages generated by sequentially culturing, please set sample_type = 2
#' @param sample_type the default value of sample_type = 1
#' @param size remove all adjacent mutations smaller than "size", the default value of size = 5
#'
#' @return The informative MT variants
#' @export


MT.feature.selection <- function(distance_list, MT_variants_detected_matrix, dis_cutoff = 0.02, sample_type = 1 , size = 5 ){
	tmp.selected.MT.variants = names(distance_list[distance_list > dis_cutoff]);
	tmp.selected.MT.variants.matrix = MT_variants_detected_matrix[tmp.selected.MT.variants,];

	tmp.cor = cor(t(tmp.selected.MT.variants.matrix));
	tmp.sd = apply(tmp.cor,1,sd);

	f1 <- flexmix(tmp.sd~1, k = 2, model = FLXMRglmfix());
	tmp.clu=clusters(f1);

	tmp.mean.1 = mean(tmp.sd[which(tmp.clu==1)])
	tmp.mean.2 = mean(tmp.sd[which(tmp.clu==2)])

	tmp.clu.1=names(tmp.sd[which(tmp.clu==1)])
	tmp.clu.2=names(tmp.sd[which(tmp.clu==2)])

	##sometime the mean of one group would be Nan, so we have to repeat this process until there is no NaN
	while(is.na(tmp.mean.1) | is.na(tmp.mean.2)) {
		f1 <- flexmix(tmp.sd~1, k = 2, model = FLXMRglmfix());
	    tmp.clu=clusters(f1);

		tmp.mean.1 = mean(tmp.sd[which(tmp.clu==1)])
		tmp.mean.2 = mean(tmp.sd[which(tmp.clu==2)])

		tmp.clu.1=names(tmp.sd[which(tmp.clu==1)])
		tmp.clu.2=names(tmp.sd[which(tmp.clu==2)])


	}

	if(tmp.mean.1 > tmp.mean.2) {

	tmp.large.sd = tmp.clu.1
	tmp.small.sd = tmp.clu.2

	}else{
	tmp.large.sd = tmp.clu.2
	tmp.small.sd = tmp.clu.1

	}

	#if your lineages generated by sequentially culturing, please set sample_type = 2
	#if your lineages come from distinct cell lines or patients samples, which don't have the same ancestor, please et sample_type = 1
	#In general, your lineages didn't generated from the same ancestor by sequentially culturing

	if( sample_type == 1){

	tmp.final.MT.variant = tmp.large.sd

	}else{

	tmp.final.MT.variant = tmp.small.sd

	}


	#######remove consecutive MT variants########
	final.MT.variant = remove_adjacent_MT_variants(tmp.final.MT.variant, size = size)

	return(final.MT.variant)

}
